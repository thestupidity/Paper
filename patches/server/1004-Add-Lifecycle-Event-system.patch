From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Tue, 18 Jul 2023 17:49:38 -0700
Subject: [PATCH] Add Lifecycle Event system

This event system is separate from Bukkit's event system and is
meant for managing resources across reloads and from points in the
PluginBootstrap.

diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9b34a4d54890c415335147b660393f03a8a8ba3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -0,0 +1,52 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ResourceRegistrar;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.registrar.StaticRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.slf4j.Logger;
+
+@DefaultQualifier(NonNull.class)
+public final class LifecycleEventRunner {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public static <O extends LifecycleEventOwner<O>, E extends LifecycleEvent> void callEvent(final LifecycleEventType<O, E> eventType, final E event) {
+        final AbstractLifecycleEventType<O, E> lifecycleEventType = (AbstractLifecycleEventType<O, E>) eventType;
+        lifecycleEventType.forEachHandler(registeredHandler -> {
+            try {
+                registeredHandler.lifecycleEventHandler().run(event);
+            } catch (Throwable ex) {
+                LOGGER.error("Could not run '{}' lifecycle event handler from {}", lifecycleEventType.name(), lifecycleEventType.getPluginMeta(registeredHandler.owner()).getDisplayName(), ex);
+            }
+        });
+    }
+
+    public static void unregisterAllEventHandlersFor(final Plugin plugin) {
+        for (final LifecycleEventType<?, ?> lifecycleEventType : LifecycleEvents.LIFECYCLE_EVENT_TYPES) {
+            removeEventHandlersOwnedBy(lifecycleEventType, plugin);
+        }
+    }
+
+    private static <O extends LifecycleEventOwner<O>> void removeEventHandlersOwnedBy(final LifecycleEventType<O, ?> eventType, final Plugin possibleOwner) {
+        final AbstractLifecycleEventType<O, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?>) eventType;
+        lifecycleEventType.removeMatching(registeredHandler -> lifecycleEventType.getPluginMeta(registeredHandler.owner()).getName().equals(possibleOwner.getPluginMeta().getName()));
+    }
+
+    public static <O extends LifecycleEventOwner<O>, R extends ResourceRegistrar> void callStaticRegistrarEvent(final LifecycleEventType<O, RegistrarEvent<R>> lifecycleEventType, final R registrar) {
+        callEvent(lifecycleEventType, new StaticRegistrarEventImpl<>(registrar));
+    }
+
+    public static <O extends LifecycleEventOwner<O>, R extends ResourceRegistrar> void callReloadableRegistrarEvent(final LifecycleEventType<O, RegistrarEvent.Reloadable<R>> lifecycleEventType, final R registrar, final RegistrarEvent.Reloadable.Cause cause) {
+        callEvent(lifecycleEventType, new ReloadableRegistrarEventImpl<>(registrar, cause));
+    }
+
+    private LifecycleEventRunner() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..aaf1ce6aa3de64704753949d832fcdd0988460eb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizedLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.SimpleLifecycleEventType;
+import java.util.function.Function;
+
+public class LifecycleEventTypeProviderImpl implements LifecycleEventTypeProvider {
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <O extends LifecycleEventOwner<O>, E extends LifecycleEvent, T extends LifecycleEventType<? super O, ? super E>> void register(final O owner, final T eventType, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        ((AbstractLifecycleEventType<? super O, E>) eventType).register(owner, lifecycleEventHandler);
+    }
+
+    @SuppressWarnings("unchecked")
+
+    @Override
+    public <O extends LifecycleEventOwner<O>, E extends LifecycleEvent, T extends LifecycleEventType<? super O, ? super E>> void registerAsMonitor(final O owner, final T eventType, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        ((AbstractLifecycleEventType<? super O, E>) eventType).registerAsMonitor(owner, lifecycleEventHandler);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <O extends LifecycleEventOwner<O>, E extends LifecycleEvent, T extends LifecycleEventType.Prioritized<? super O, ? super E>> void registerWithPriority(final O owner, final T eventType, final LifecycleEventHandler<? super E> lifecycleEventHandler, final int priority) {
+        ((PrioritizedLifecycleEventType<? super O, E>) eventType).registerWithPriority(owner, lifecycleEventHandler, priority);
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner<O>, E extends LifecycleEvent> LifecycleEventType<O, E> simple(final String name, final Function<? super O, ? extends PluginMeta> getPluginMeta) {
+        return new SimpleLifecycleEventType<O, E>(name, getPluginMeta);
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner<O>, E extends LifecycleEvent> LifecycleEventType.Prioritized<O, E> prioritized(final String name, final Function<? super O, ? extends PluginMeta> getPluginMeta) {
+        return new PrioritizedLifecycleEventType<O, E>(name, getPluginMeta);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/package-info.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..da506a24a1c22f41a844d6b113751128e19b67fb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.lifecycle.event;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..2983f4135cad909901a665573776fbc330704891
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
@@ -0,0 +1,4 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+public record ReloadableRegistrarEventImpl<R extends ResourceRegistrar>(R registrar, Cause cause) implements RegistrarEvent.Reloadable<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..41c23d28f97af4ad8124783f8b41a9f42309cbfe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
@@ -0,0 +1,4 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+public record StaticRegistrarEventImpl<R extends ResourceRegistrar>(R registrar) implements RegistrarEvent<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/package-info.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..624d3aa3c81f15c10eb3115a2bc7c316b254df91
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..688c6c3c63e3888f9e6dd835dd108289d56d1c02
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner<O>, E extends LifecycleEvent> implements LifecycleEventType<O, E> {
+
+    private final String name;
+    private final Function<? super O, ? extends PluginMeta> getPluginMeta;
+
+    protected AbstractLifecycleEventType(final String name, final Function<? super O, ? extends PluginMeta> getPluginMeta) {
+        this.name = name;
+        this.getPluginMeta = getPluginMeta;
+    }
+
+    @Override
+    public String name() {
+        return this.name;
+    }
+
+    public PluginMeta getPluginMeta(final O owner) {
+        return this.getPluginMeta.apply(owner);
+    }
+
+    public abstract void forEachHandler(Consumer<? super RegisteredHandler<O, E>> consumer);
+
+    public abstract void removeMatching(Predicate<? super RegisteredHandler<O, E>> predicate);
+
+    public abstract void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler);
+
+    public abstract void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler);
+
+    public record RegisteredHandler<O, E extends LifecycleEvent>(O owner, LifecycleEventHandler<? super E> lifecycleEventHandler) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..810c8d436e78485fa9b95487ec2dbd2625e10a13
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
@@ -0,0 +1,68 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import java.util.Comparator;
+import java.util.NavigableSet;
+import java.util.OptionalInt;
+import java.util.TreeSet;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public class PrioritizedLifecycleEventType<O extends LifecycleEventOwner<O>, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E> implements LifecycleEventType.Prioritized<O, E> {
+
+    private static final OptionalInt MONITOR_PRIORITY = OptionalInt.empty();
+    private static final OptionalInt DEFAULT_PRIORITY = OptionalInt.of(0);
+
+    private final NavigableSet<PrioritizedHandler<O, E>> handlers = new TreeSet<>(Comparator.comparing(PrioritizedHandler::priority, (o1, o2) -> {
+        if (o1.equals(o2)) {
+            return 0;
+        } else if (o1.isEmpty()) {
+            return 1;
+        } else if (o2.isEmpty()) {
+            return -1;
+        } else {
+            return Integer.compare(o1.getAsInt(), o2.getAsInt());
+        }
+    }));
+
+    public PrioritizedLifecycleEventType(final String name, final Function<? super O, ? extends PluginMeta> getPluginMeta) {
+        super(name, getPluginMeta);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.registerWithPriority(owner, lifecycleEventHandler, DEFAULT_PRIORITY);
+    }
+
+    @Override
+    public void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.registerWithPriority(owner, lifecycleEventHandler, MONITOR_PRIORITY);
+    }
+
+    public void registerWithPriority(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler, final int priority) {
+        this.registerWithPriority(owner, lifecycleEventHandler, OptionalInt.of(priority));
+    }
+
+    public void registerWithPriority(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler, final OptionalInt priority) {
+        this.handlers.add(new PrioritizedHandler<>(new RegisteredHandler<>(owner, lifecycleEventHandler), priority));
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final PrioritizedHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler.handler());
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(prioHandler -> predicate.test(prioHandler.handler()));
+    }
+
+    private record PrioritizedHandler<O extends LifecycleEventOwner<O>, E extends LifecycleEvent>(RegisteredHandler<O, E> handler, OptionalInt priority) {}
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..92f951129dde5544631f4e28563f453fa3b622e6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public class SimpleLifecycleEventType<O extends LifecycleEventOwner<O>, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E> {
+
+    final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    int nonMonitorIdx = 0;
+
+    public SimpleLifecycleEventType(final String name, final Function<? super O, ? extends PluginMeta> getPluginMeta) {
+        super(name, getPluginMeta);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.handlers.add(this.nonMonitorIdx, new RegisteredHandler<>(owner, lifecycleEventHandler));
+        this.nonMonitorIdx++;
+    }
+
+    @Override
+    public void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.handlers.add(new RegisteredHandler<>(owner, lifecycleEventHandler));
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final RegisteredHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler);
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(predicate);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/package-info.java b/src/main/java/io/papermc/paper/plugin/lifecycle/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..7b6d67d8dd53af3aa9add193035d72f0ec3eee3e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.lifecycle;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 9c7552968b8c017c71a7a77557a66a03ed89f125..773060422cc89778c2696d5c7f1361d9e52ee9bc 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -261,6 +261,15 @@ class PaperPluginInstanceManager {
                 + pluginName + " (Is it up to date?)", ex, plugin); // Paper
         }
 
+        // Paper start - lifecycle event system
+        try {
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.unregisterAllEventHandlersFor(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering lifecycle event handlers for "
+                + pluginName + " (Is it up to date?)", ex, plugin);
+        }
+        // Paper end
+
         try {
             this.server.getMessenger().unregisterIncomingPluginChannel(plugin);
             this.server.getMessenger().unregisterOutgoingPluginChannel(plugin);
diff --git a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
index 31ec730e63adf82bf9ac02331bc7f186b98c35cf..f7fca2c07cbd193eceb2d49a4f1ed3face0180c2 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
@@ -32,6 +32,7 @@ public class BootstrapProviderStorage extends SimpleProviderStorage<PluginBootst
                 try {
                     BootstrapContext context = PluginBootstrapContextImpl.of(provider, PluginInitializerManager.instance().pluginDirectoryPath());
                     provided.bootstrap(context);
+                    // TODO somehow lock lifecycle event handler creation for this BootstrapContext object (might require changing it away from a record)
                     return true;
                 } catch (Throwable e) {
                     LOGGER.error("Failed to run bootstrapper for %s. This plugin will not be loaded.".formatted(provider.getSource()), e);
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index dae36c6452ccd57a436dd918547b64d59957ab0a..7ab5397a7696989d7ef03eec346ea534ce6681ff 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -130,6 +130,9 @@ public class Main {
             Path path1 = Paths.get("server.properties");
             DedicatedServerSettings dedicatedserversettings = new DedicatedServerSettings(optionset); // CraftBukkit - CLI argument support
 
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.LifecycleEvents.DUMMY,new io.papermc.paper.plugin.lifecycle.dummy.DummyResourceRegistrar(), io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent.Reloadable.Cause.INITIAL); // Paper
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.callEvent(io.papermc.paper.plugin.lifecycle.event.LifecycleEvents.NON_REGISTRAR_RELATED_EVENT, new io.papermc.paper.plugin.lifecycle.dummy.NonRegistrarEvent()); // Paper
+
             dedicatedserversettings.forceSave();
             Path path2 = Paths.get("eula.txt");
             Eula eula = new Eula(path2);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 435f5ee3388f5da93df938c43ea2578f7d586407..383fe5696e066a4993e357eb2286de1a74fde5a3 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -635,6 +635,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
         this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
+        io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.callStaticRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.LifecycleEvents.DUMMY_STATIC, new io.papermc.paper.plugin.lifecycle.dummy.DummyResourceRegistrar()); // Paper
         this.connection.acceptConnections();
     }
     // CraftBukkit end
@@ -2092,6 +2093,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
             this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
             org.bukkit.craftbukkit.block.data.CraftBlockData.reloadCache(); // Paper - cache block data strings, they can be defined by datapacks so refresh it here
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.LifecycleEvents.DUMMY,new io.papermc.paper.plugin.lifecycle.dummy.DummyResourceRegistrar(), io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent.Reloadable.Cause.RELOAD); // Paper
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper - fire after everything has been reloaded
         }, this);
 
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
new file mode 100644
index 0000000000000000000000000000000000000000..c647fd9cef4f82b6ef17a942c208cc37bf5e99c2
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
@@ -0,0 +1 @@
+io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProviderImpl
